Большинство из нас знакомы с несколькими фреймворками для написания бэкенда.
Так вот сегодня мы расширим ваш круг знакомств.
Знакомьтесь - Loopback от IBM.
Loopback - это всего лишь один из продуктов Strongloop, но именно о нем мы будем говорить, т.к. именно он предоставляет базовый функционал для написания бэкенда.
Итак, зачем забивать голову знанием об еще одном фреймворке? А есть целый список причин:
1. Он бесплатный (если некто не хочет использовать бесплатный продукт, он может заплатить за множество дополнительного функционала);
2. Большое сообщество программистов, использующих именно этот фреймворк;
3. Возможность быстро развернуть бэкенд со старта;
4. Возможность миграции моделей с готовой БД;
5. Возможность автомиграции моделей в пустую БД;
6. Наличие наглядного живого интерфейса explorer;
7. Возможность легко и понятно задавать сложную вложенную структуру получаемого объекта(ов);
8. Встроенная возможность легко и быстро настроить Push Notifications;
9. Возможность работы как с реляционными, так и с нереляционными БД с одинаковой легкостью;
10. Наличие большой открытой базы работающих (что важно!) и детально пошагово расписанных примеров с исчерпывающей документацией.
Впечатляет? А ведь это еще не все...

Мы - программисты (в большинстве своем). Мы не хотим писать код с нуля, мы хотим использовать готовые решения! Мы хотим беречь свое время! А Loopback дает нам такую возможность. Сочетание большого количества встроенных возможностей с понятными и удобными интерфейсами, а также максимально подробными примерами позволяет быстро ориентироваться и быстро создавать рабочие сервера.

Чтобы показать как легко сделать серверное приложение, создадим его.
Мне было интересно изучить методы создания acl в приложении, написанном на Loopback. При этом я поставил задачу написать такое приложение с использованием mongoDB.
Документация у Loopback интересная и понятная, но достаточно обширная. Поэтому вооружившись клавиатурой, я спросил у Google "loopback пример acl". Google ответил преданно, Google ответил искренне: https://github.com/strongloop/loopback-example-access-control
Да, вот так сразу готовый пример, расписанный до мелочей. Одна лишь деталь упущена: mongoDB. Переживем, не беда, перегорюем как нибудь. А хотя, просто возьмем базу mongoDB, установим в модуль loopback-connector-mongodb и настроим приложение. Хотя это тоже слишком сложно. А что, если взять и вбить в терминале команду slc loopback:datasource ?

Так, медленно и ненавязчиво мы подошли к созданию приложения на Loopback. И для его создания нам нужно-то нам всего 5 команд:
1. slc loopback
2. slc loopback:datasource
3. slc loopback:model
4. slc loopback:relation
5. slc loopback:acl

Первая команда создаст директорию с проектом и нужной стрктурой папок и файлов, установит некоторые необходимые модули.
Вторая команда установит модуль-коннектор для выбранной нами БД (причем, в списке готовых решений кроме mongoDB и MySQL есть достаточно общирный список конкурирующих вариантов альтернативных баз данных.
Команда slc loopback:model поможет нам создать и настроить нужные модели, которые в последствии станут таблицами или коллекциями БД с настроенными полями нужных типов.
slc loopback:relation подскажет как правильно установить нужные нам связи между созданными моделями для того, чтобы в будущем мы смогли запрашивать у бэкенда сложные объекты, содержащие всю интересующую нас информацию, одним стандартным запросом.
Ну и, наконец, та изюминка, ради которой и затевалась вся игра: acl (access control lists). Команда slc loopback:acl подскажет какие типы правил мы можем установить.
Каждая из приведенных команд предоставляет набор селекторов и подсказок, которые максимально упрощают и ускоряют процесс создания сущностей.

Проделанный пример отличается от любезно предоставленного Loopbackом примера используемой базой данных. Для некоторых ORM эта деталь могла бы стать серьезной или даже непреодолимой проблемой, но только не для Loopback! Использовать другую БД так же легко, как выбрать из списка подходящий коннектор для серверного приложения. Единственная правка, которую пришлось ввести - это поменять тип поля id в моделях с number на string.

В проделанном примере мы устанавливаем acl для 
-всех методов всех моделей
-всех методов выбранной модели
-для одного конкретного метода выбранной модели
для всех пользователей или же категорий пользователей
-предопределенных фрэймворком (например, authenteficated),
-определенных нами путем раздачи ролей (admin),
-выбранных нами по некоторыму принципу (teamMembers)
При этом, методы и принцип выборки могут быть написаны нами в сколь угодно сложном и изощренном варианте. Вместо teamMembers это могут быть пользователи с именем Джек или же пользователи, родственники которых страдают от аллергии на арахис (последний вариант, правда, подразумевает несколько иную структуру БД для получения требуемой информации о пользователе).

Итак, проделав все указанные команды в терминале, создав модели user, team, project и связи между ними, подразумевающие наличие в каждой каманде и каждом проекте владельца и участников, создав правила достапа для всез категорий пользователей, в т.ч. и для созданной нами роли админа, и для группы, включающей всех авторизованных пользователей, а также беззастенчиво скопирвав 3 маленьких нестандартных метода (listProjects, donate, withdraw) для модели проекта из примера (не написание этих методов есть цель этой статьи), и написав по примеру простейший алгоритм определения teamMembers, получаем сразу готовый к работе проект.

Запуск проекта производится командой "node ." в терминале. После чего мы можем обозревать всю мощь созданного нми проекта в графическов интерфейсе explorer по ссылке http://0.0.0.0:3000/explorer , где есть все созданные нами модели, и для каждой из них длинный список стандартных методов с кратким описанием, а также список пользовательских методов с описанием, заданным пользователем. Мало того, каждый из методов может быть опробован в действии, а все изменения исправно будут внесены в БД.

Дело за малым - выбрать инструмент для написания фронтенд части и, собственно, создать ее, обращаясь к готовому REST API, созданному за считанные минуты с помощью Loopback.
